---
layout:     post
title:      "Empty try-catch vs nothing"
date:       2016-07-29
summary:    Having an empty try catch is different from nothing.
category:   c++
draft: true
tags:
 - c++ 
 - templates
---


> As control passes from a throw-expression to a handler, destructors are invoked for all automatic objects constructed since the try block was entered. The automatic objects are destroyed in the reverse order of the completion of their construction.
{:.standards para="[except.ctor]/1"}

> The process of calling destructors for automatic objects constructed on the path from a try block to a throw-expression is called “stack unwinding.” [...]
{:.standards para="[except.ctor]/3"}

> [When the exception handling mechanism cannot find a handler for a throw exception], `std::terminate()` is called (18.8.3). In the situation where no matching handler is found, it is implementation-defined whether or not the stack is unwound before `std::terminate()` is called. [...]
{:.standards para="[except.terminate]/2"}

As such, if you want to guarantee that your automatic objects have their destructors run in the case of an unhandled exception (e.g. some persistent storage must be mutated on destruction) then `try {/*code*/} catch (...) {throw;}` will do that, but `{/*code*/}` will not.
